#!/usr/bin/python3
"""
    @file           rbtScene

    @brief          ROS Bag testing for scene image processor. 
                    The bag file contains calibration and processing data.

                    NOTE: This new test script adopts the new configuration loading mechanism
                    The original rbtScene is kept for now for the before things are all upgraded.

    @author         Patricio A. Vela,   pvela@gatech.edu
                    Yiye Chen,          yychen2019@gatech.edu
    @date           2022/07/01
                    2022/08/07[Modified]

"""
from email import message_from_binary_file
from benedict import benedict
import os

import glob
import shutil
import numpy as np
import os
import subprocess
import yaml
import threading
import time
import cv2
import matplotlib.pyplot as plt
import argparse
import copy
from pathlib import Path
import pickle

# ROS
import rospy
import rosgraph
import rosbag
from std_msgs.msg import UInt8

# Utils
from ROSWrapper.subscribers.Images_sub import Images_sub
from camera.utils.display import display_images_cv, display_rgb_dep_cv
from Surveillance.deployment.utils import display_option_convert, calc_closest_factors

# Surveillance system
from Surveillance.deployment.Base import BaseSurveillanceDeploy
from Surveillance.deployment.Base import Params as bParams
from Surveillance.deployment.utils import terminate_process_and_children
from Surveillance.utils.imgs import draw_contour
#from Surveillance.utils.specifications import specifications
from Surveillance.utils.configs import CfgNode_SurvRunner as CfgSurv

# preparation
lock = threading.Lock()

timestamp_beginning = None
timestamp_ending = None
roscore_proc = None

# To be built
call_back_id = 0

def get_args():
    parser = argparse.ArgumentParser(
                            description="Extract puzzle layer from frames in saved rosbag file.")
    parser.add_argument("yfile", type=str, 
                        help="The customized configuration files to overwrite the default parameters")
    parser.add_argument("fi", type=int,nargs="?",default=1,
                        help="The first frame to extract from ROSbag stream.")
    parser.add_argument("fl", type=int,nargs="?",
                        help="The last frame to extract from ROSbag stream (else gets only frame fi).")
    parser.add_argument("--prefix");
    args = parser.parse_args()

    if args.fl is None:
      args.fl = args.fi

    cfg = CfgSurv()
    cfg.load_defaults()
    cfg.merge_from_files(args.yfile)

    print(cfg.source.rosbag)

    return args, cfg

class ImageListener:
    def __init__(self, opt):

        self.opt = opt
        self.ind = 1

        # Convert display code
        self.opt.general.display = display_option_convert(self.opt.general.display)

        # Initialize the saving folder

        if self.opt.output.save:
            if not self.opt.general.real_time:
                self.opt.output.path = Path(self.opt.rosbag_name).stem
            else:
                self.opt.output.path = 'realtime'

            # Clear up the space
            if os.path.exists(self.opt.output.path):
                shutil.rmtree(self.opt.output.path)
            os.makedirs(self.opt.output.path, exist_ok=True)

        # Data captured
        self.RGB_np = None
        self.D_np = None

        self.rgb_frame_stamp = None
        self.rgb_frame_stamp_prev = None

        # Initialize a node
        rospy.init_node("rosbag_frame_puzzle_layer")

        # Build up the surveillance system from the rosbag
        # @todo Hard-coded parameters should be in a yaml file.
        configs_surv = bParams(
            visualize=False,
            vis_calib=self.opt.general.vis_calib,
            ros_pub=False
        )

        # build the surveillance deployer
        rosbagfile = os.path.expanduser(cfg.source.rosbag)
        self.surv = BaseSurveillanceDeploy.buildFromRosbag(rosbagfile, configs_surv, cfg)

        # Initialize a subscriber
        Images_sub([self.opt.TopicNames.rgb,
                    self.opt.TopicNames.depth], 
                    callback_np=self.callback_rgbd)

        print("Initialization ready, waiting for the data...")

    def callback_rgbd(self, arg_list):

        if self.opt.general.verbose:
            print("Get to the callback")

        RGB_np = arg_list[0]
        D_np = arg_list[1]
        rgb_frame_stamp = arg_list[2].to_sec()

        # np.integer includes both signed and unsigned, whereas the
        # np.int only includes signed
        if np.issubdtype(D_np.dtype, np.integer):
            if self.opt.general.verbose:
                print("converting the depth scale")
            D_np = D_np.astype(np.float32) * self.surv.depth_scale

        with lock:
            self.RGB_np = RGB_np.copy()
            self.D_np = D_np.copy()
            self.rgb_frame_stamp = copy.deepcopy(rgb_frame_stamp)
    
    def run_system(self):

        with lock:

            global call_back_id

            if self.RGB_np is None:
                if self.opt.general.verbose:
                    print('No data')
                return

            rgb_frame_stamp = copy.deepcopy(self.rgb_frame_stamp)

            # Skip images with the same timestamp as the previous one
            if rgb_frame_stamp != None and self.rgb_frame_stamp_prev == rgb_frame_stamp:

                time.sleep(0.001)
                # if self.opt.general.verbose:
                #     print('Same timestamp')
                return
            else:
                self.rgb_frame_stamp_prev = rgb_frame_stamp
                RGB_np = self.RGB_np.copy()
                D_np = self.D_np.copy()
#D                activity = copy.deepcopy(self.activity_label)

            if self.opt.general.verbose:
                print("Running the Surveillance on the test data")

            if self.opt.output.save:
                # Save for debug
                cv2.imwrite(os.path.join(self.opt.output.path, f'{str(call_back_id).zfill(4)}_rgb.png'), self.RGB_np[:, :, ::-1])

            self.surv.process(RGB_np, D_np)

            # Puzzle layer direct from surveillance system without 
            # postprocessing.
            puzzleImg  = self.surv.scene_interpreter.get_layer(
                                     "puzzle",mask_only=False, BEV_rectify=True)
            puzzleMask = self.surv.scene_interpreter.get_layer(
                                      "puzzle",mask_only=True, BEV_rectify=True)
            #puzzleMask = puzzleMask.astype(int)
            #puzzleMask *= 255;
            

            display_images_cv([puzzleImg[:,:,::-1]], ratio=1.0,
                              window_name="Puzzle Layer: Image")
            #display_images_cv([puzzleMask[:,:,::-1]], ratio=0.5,
                              #window_name="Puzzle Layer: Mask")

            if self.opt.output.save:
                cv2.imwrite(os.path.join(self.opt.output.path, f'{str(call_back_id).zfill(4)}_puzzle.png'), puzzleImg[:, :, ::-1])
                cv2.imwrite(os.path.join(self.opt.output.path, f'{str(call_back_id).zfill(4)}_mask.png'), puzzleImg[:, :, ::-1])


            # Display
            if self.opt.general.display[0]:
                display_images_cv([RGB_np[:, :, ::-1]], ratio=0.5, window_name="Source RGB")
#            if self.opt.general.display[1]:
#                self.surv.scene_interpreter.vis_layer_realtime(layer_name="human", BEV_rectify=False, \
#                    window_name="Hand layer", ratio=0.5, tracker=True)
#            if self.opt.general.display[2]:
#                self.surv.scene_interpreter.vis_layer_realtime(layer_name="robot", BEV_rectify=False, \
#                    window_name="Robot layer", ratio=0.5)

            # Force display to refresh.
            cv2.waitKey(1)
            self.ind = self.ind + 1
            print("index updated")

        # Only applied when working on rosbag playback
        if self.opt.general.real_time is False:

            global timestamp_beginning
            global timestamp_ending
            global roscore_proc

            print(f'Current frame time: {np.round(rgb_frame_stamp-timestamp_beginning,2)}s')
            print('\n\n')

            # # Debug only
            if self.opt.general.verbose:
                print(f'Last frame time: {np.round(timestamp_ending-timestamp_beginning,2)}s')

            # We ignore the last 2 seconds
            if timestamp_ending is not None and abs(rgb_frame_stamp - timestamp_ending) < 2:

                print('Shut down the system.')
                rospy.signal_shutdown('Finished')
                # Stop the roscore if started from the script
                if roscore_proc is not None:
                    terminate_process_and_children(roscore_proc)
        else:
            print('\n\n')


if __name__ == "__main__":

    args, cfg = get_args()                      # parse argument. 

    # update the args about the existence of the activity topic
    rosbagfile = os.path.expanduser(cfg.source.rosbag)
    bag = rosbag.Bag(rosbagfile)

    # @todo   If check below not so consistent with yaml loading.
    #         Need to first check if it is a field.
    if cfg.general.restart:
        subprocess.call(['killall rosbag'], shell=True)
        subprocess.call(['killall rosmaster'], shell=True)

    # Start the roscore if not enabled
    if not rosgraph.is_master_online():
        roscore_proc = subprocess.Popen(['roscore'], shell=True)
        # wait for a second to start completely
        time.sleep(1)

    listener = ImageListener(cfg)

    plt.ion()
    if cfg.general.real_time is False:
        # Get basic info from the rosbag
        info_dict = yaml.safe_load(
            subprocess.Popen(['rosbag', 'info', '--yaml', rosbagfile], stdout=subprocess.PIPE).communicate()[0])

        timestamp_beginning= info_dict['start']
        timestamp_ending = info_dict['end']

        print('Playback the rosbag recordings')

        # Need to start later for initialization
        # May need to slow down the publication otherwise the subscriber won't be able to catch it
        # -d:delay; -r:rate; -s:skip; -q no console display
        command = "rosbag play {} -d 2 -r 1 -s 15 -q --topic {} {} {}".format(rosbagfile, cfg.TopicNames.rgb,cfg.TopicNames.depth, cfg.TopicNames.activity)

        print('============')
        print(command)
        print('============')
        try:
           # Be careful with subprocess, pycharm needs to start from the right terminal
           # environment (.sh instead of shortcut).
           # See https://stackoverflow.com/a/3478415
           # We do not want to block the process
           subprocess.Popen(command, shell=True)
        except:
           print("Cannot execute the bash command: \n {}".format(command))
           exit()

    print(args.fi)
    print(args.fl)
    while not rospy.is_shutdown() and listener.ind <= args.fl:
        listener.run_system()

    print("Hit last index. Press a key to quit.")
    cv2.waitKey(0)
    if not rospy.is_shutdown():
      rospy.signal_shutdown("Last frame required has been processed.")

    if cfg.output.save and cfg.general.debug_individual_folder:
        # Mainly for debug
        def resave_to_folder(target):
            file_list = glob.glob(os.path.join(listener.opt.output.path, f'*{target}.png'))

            if os.path.exists(f'{target}'):
                shutil.rmtree(f'{target}')
            os.makedirs(f'{target}', exist_ok=True)

            for file_path in file_list:
                shutil.copyfile(file_path, os.path.join(f'{target}', os.path.basename(file_path)))

        target_list = ['bTrack_SolID']

        for i in target_list:
            resave_to_folder(i)
